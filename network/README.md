## 网络题

#### POST和GET请求的区别

总共从三个方面来说明：

1. 请求资源位置。GET的请求参数放在QS中，POST放在body中。
2. 长度限制。GET的URL会根据游览器的长度限制，POST在body中无限制。
3. 安全性。POST相对于GET请求安全性更高一些。

#### OSI模型和TCP/IP模型

1. OSI模型从下至上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
2. TCP/IP模型从下至上：硬件、数据链路层、网络层、传输层、应用层。

```
网络层协议：IP协议
传输层：TCP UDP
应用层：HTTP HTTPS FTP
```

#### TCP/IP的区别

+ TCP 是有连接，字节流协议。UDP 是无连接的数据报协议。
+ TCP 连接需要握手，确定通信双方，不适用于多播和广播。UDP 发送数据之前不需要握手，适用于广播。
+ TCP 有确认应答、顺序控制、重传机制，比较可靠。UDP 没有重传机制，会经常丢包也会多次达到，缺乏可靠。

#### TCP为什么要三次握手，四次挥手？

三次握手：

+ 第一次握手(SYN=1, seq=x):

    + 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。
    + 发送完毕后，客户端进入 SYN_SEND 状态。

+ 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

    + 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。

+ 第三次握手(ACK=1，ACKnum=y+1)

    + 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

+ 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

四次挥手

刚开始双方都处于ESTABLISHED（已确定）状态，加入客户端先发起挥手。

+ 第一次挥手(FIN=1，seq=x)
    + 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
    + 发送完毕后，客户端进入 FIN_WAIT_1 状态。

+ 第二次挥手(ACK=1，ACKnum=x+1)

    + 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
    + 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

+ 第三次挥手(FIN=1，seq=y)

    + 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。
    + 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。

+ 第四次挥手(ACK=1，ACKnum=y+1)

    + 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。
    + 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。
    + 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

#### 对称加密和非对称加密的区别？分别有哪些算法的实现？

对称加密算法，是甲乙双方使用同一种加密规则，加解密使用相同的秘钥，安全性不高，但是速度快。例如：AES。
非对称加密算法，是甲乙双方使用一对秘钥，分为公钥和私钥，客户端使用公钥对传输内容进行加密，服务端使用私钥对内容解密。安全性稍微高一点。例如：RSA。

#### HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么?

HTTPS是身披SSL外壳的HTTP。
HTTPS = HTTP + 加密 + 认证 + 完整性验证
HTTPS采用混合加密机制。就是共享密码加密和公开秘钥加密的混合加密方式。

使用公开秘钥加密也是存在问题的，如何证明公开密钥就是服务端发行的公开密钥。为了解决这个问题，可以使用数字证书认证机构和其相关颁发的公开密钥证书。

数字认证机构会对服务端的公开密钥进行数字签名，然后将这个公钥放入公钥证书中，服务端就将这个证书发送给客户端。

客户端接收到数字证书后，使用数字认证结机构的公开密钥，对这张证书上的数字签名进行验证。

HTTPS的安全通信机制（单向认证）：

1、客户端发送clientHello给后端，报文中包含客户端支持的SSL协议版本，加密组件列表。发起HTTPS请求。
2、后端可SSL通信时，会以ServerHello报文作为应答，报文中包含SSL版本和加密组件，这个组件是从客户端的列表中选出来的。
3、后端从数字认证机构申请数字证书（包括服务端公钥和签名），后端发送Certi报文，报文中包含公开秘钥证书。
4、最后服务端发送ServerhelloDone，通知客户端SSL握手协商部分结束。
5-1、客户端通过CA公钥，采用相同hash散列函数计算信息摘要，通过CA公钥去解密签名，证明证书的可信，然后取出服务端公钥。
5-2、客户端发送ClientKeyExchange报文给后端，报文中包含一个随机加密码。
6、客户端发送changeCipherSpec报文，提示后端之后会以这个随机加密秘钥加密。
7、客户端发送Finished报文。
8-1、后端使用秘钥去解密这个随机数，得要随机数。
8-2、后端同时也会发送changeCipherSpec 和Finished 报文，SSL链接就算完成。

双向认证：

1、客户端发送clientHello，报文含有客户端支持的SSL版本、加密组件。
2、后端发送ServerHello回应，报文中包含SSL版本和加密组件。
3、后端申请数字证书，后端发送Certificate报文，报文中含有服务端公钥。
4、后端发送ServerHelloDone，告知SSL握手协议结束。
5、客户端拿到CA公钥，通过hash散列函数计算得到信息摘要，然是通过CA公钥去解密签名，对比信息摘要，如果一致获取后端公钥。
6、客户端发送客户端证书给服务端，证书中含有客户端公钥
7、客户端发送支持的加密组件给服务端，供其选择。
8、后端选择加密组件后，用刚才的客户端公钥去加密选好的加密方案
9、客户端使用自己的私钥去解密选好的加密方案，客户端使用一个随机数，用刚得到的服务端公钥去加密这个随机数形成密文，发送给服务端。

5、HTTPS是如何实现验证身份和验证完整性的？

#### 如何用Charles抓HTTPS的包？其中原理和流程是什么？

常用的抓包工具的抓包方式都是使用中间人，对客户端伪装成服务端，对服务端伪装成客户端。

+ 截获客户端的请求，伪装成中间人客户端去访问HTTPS请求。
+ 接受服务端返回，伪装成中间人服务端向客户端发送数据。

1、当客户端向服务端发送Https请求时，后端会将服务端公钥和前面发送给客户端，此时charles截获通过CA公钥完成验证，获取到服务端公钥，然后通过自己的证书替换掉服务端的证书发送给客户端。

2、客户端接收到charles证书，通过charles root证书解密获取到charles公钥，然后使用公钥去加密随机数，发送到charles时，用charles私钥解密获取随机数，然后使用服务端公钥加密改随机数然后返回给后端。

#### 什么是中间人攻击？如何避免？

中间人攻击主要是，中间人伪造一张服务端证书给客户端，让客户端觉得这是一张正确的证书。

采用SSL-Pinning，一般有两种方式：

+ 证书锁定：需要在客户端代码内置仅接受指定域名的证书，不接受游览器或操作系统内置的CA根证书对应的任何证书，这种方案存在有效期问题，需要在证书快要过期之前重新内置到app内。
+ 公钥锁定：提取证书中的公钥并内置到客户端中，通过对比服务端的公钥值来验证。

#### App 网络层有哪些优化策略？

https://www.jianshu.com/p/fcf5c2add9e0
http://mrpeak.cn/blog/ios-network/
https://tech.meituan.com/2017/03/17/shark-sdk.html

DNS映射。
合理的并发数。
请求合并。
请求的安全性。
网络环境监测。
请求成功率监测。

#### 说一下HTTP协议以及经常使用的code码的含义。

+ 200、204：请求被正常处理了。
+ 300：重定向
+ 400：客户端的请求错误，请求报文中出现错误语法。
+ 404：服务器上无法找到请求资源。
+ 500：服务器内部错误。
#### 线程的生命周期

创建线程对象并启动属于就绪态，通过CPU的调度在运行态和就绪态之间切换，如果有锁就会成为阻塞态，诚信执行完毕后变为死亡态。

#### 说一下线程之间的通信？

1、假设两个线程A和B同时访问一个资源C，为了防止资源抢夺，A在读取C的时候加锁，然后读取完成修改吧数据写入C，最后解锁。在线程A对C操作时，B是无法访问的，只有A解锁之后，B才能访问资源。
2、下载图片，一般都是在子线程下载完成后，切换到主线程进行渲染。

简单一点的说

+ 防止多线程抢夺资源造成的数据安全问题
+ 一个线程处理完数据传递给另一个线程
+ 一个线程处理完特定任务后，切换到另一个线程继续执行任务。

线程相关使用的类

0、NSOject PerformSelectorOnMainThread
1、NSThread
2、NSOperation && NSOperationQueue
3、GCD

三者的区别

+ NSThread 需要维护自己的生命周期，是基于pthread 封装的OC类，线程之间的并发需要自己控制。
+ NSOperation 它是基于GCD封装的抽象类，实际使用中需要使用它的子类，它不需要管理线程的生命周期和线程的同步和互斥。还可以设置任务之间的依赖关系等等。
+ GCD 是apple提出解除多线程问题的一个解决方案。使用起来简单。

NSOperation vs GCD

+ GCD是基于底层C的API，Queue是OC对象类。并且其实实现使用GCD。
+ GCD的使用比较轻量；Operation的使用比较复杂。
+ Operation控制比GCD好，可以控制操作队列的暂停、取消和回复。
+ Operation可是设置两个操作之间的依赖。
+ Operation可以监视操作或操作队列的状态。准备、执行或完成。
+ Operation可以指定可以同时运行的队列操作的最大数目，可以控制最大并发数。

GCD的几个重要概念

1、队列 queue。分为串行队列和并行队列。
2、任务 sources，可以把source创建到系统上。
3、分组 group，可以把一系列任务加到分组中，等待组中的所有任务完成才结束。
4、信号量 semaphores，控制更加复杂的并发。

Queue，执行顺序 FIFO

1、串行队列。队列中的任务一个接一个的执行，顺序执行。
2、并行队列。可以并发的执行多个任务。
3、主队列，是一个全局的串行队列，任务会在主线程中执行，主队列通过与runloop交互，把任务添加到runloop中执行。

Global Queue 队列优先级

High、Default、Low、Background

执行任务

1、async。异步执行，不用等待之前的任务是否已完成，可以立即开始新的一个任务。
2、sync。同步执行，任务执行完一个再执行下一个。

线程安全

1、GCD本身是线程安全的。把任务加入到队列中不用考虑锁。
2、避免在队列中使用锁。

经典问题

1、在主队列中同步执行。死锁。
2、在全局并行队列中同步执行，不会死锁。
3、在自定义的串行队列中同步执行，死锁。
4、在全局并发队列中异步执行，然后在主线程中同步执行，正常。

####6、什么时候会出现死锁？如何避免？

互斥锁解决了竞态条件问题，但是还有一个问题是死锁。当多个线程都互相等待着对方接受时，就会发生死锁。

减少线程间资源管理，并确保共享的资源尽量简单。

####7、说一说你对线程安全的理解？

如果多线程里访问一个共享资源，两个并发线程A和线程B同时写入和读取数据，会产生资源竞争问题。如果没有一种互斥机制来保证在多线程环境下访问共享资源。问题很难避免。

属性声明的atomic，讲一个属性声明为atomic表示每次访问改属性都会进行隐式的加锁和解锁操作。

####8、列举你知道的线程同步策略？

1、锁
2、串行队列
3、信号量

####9、有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说

1、OSSpinLock（自旋锁）。
2、NSLock（对象锁）。
3、pthread_mutex（互斥锁）。
4、@synchronized（对象锁）。
5、NSCondition
6、NSRecursiveLock（递归锁）。
7、串行队列
8、dispatch_semaphore（信号量）

自旋锁和互斥锁的区别
自旋锁，等待锁的线程会处于一直忙等状态，一直占用CPU资源
互斥锁，等待锁的线程会处于休眠状态，减少CPU的开销。

1、os_unfair_lock，OSSpinLock 的代替品，本质是一个互斥锁。
2、pthread_mutex_t：互斥锁。
3、NSLock：是对 pthread_mutex_t 的简单封装。
4、NSRecursiveLock：递归锁，是对 pthread_mutex_t 递归锁的封装。同一个线程可以多次加锁，不会造成死锁。
5、synchronized：不需要显示的创建锁对象，隐式的添加一个异常处理逻辑来保护代码，会在异常发生的时候自动释放互斥锁。

+ https://www.zybuluo.com/qidiandasheng/note/493337
+ https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/

#### dispatch_barrier_async 的作用

在并发队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续执行。通过barrier_async向并发队列中追加任务时，必须等并发队列之前的任务完成后，然后只想这个追加任务，执行完这个追加任务再继续指向后面的任务。



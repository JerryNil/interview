# 系统原理

#### 了解编译的过程么？分为哪几个步骤？
iOS使用的是编译器LLVM，编译前端是Clang，编译后端是LLVM。LLVM是编译器工具链技术的一个集合，其中的lld就是内置链接器，编译器对每个文件进行编译生成mach-O，链接器把多个mach-O合成一个mach-O。
编译的几个重要过程：

1、预处理，LLVM会预处理代码，将代码中的宏用其定义的内容进行替换。
2、LLVM会对代码进行词法分析，代码文本都会被转成特殊的token标记。
3、LLVM会对代码进行语法分析，生成AST抽象语法树，使用AST能够快速的进行静态检查，同时还能生成中间代码IR。
4、静态分析，编译器会对AST做分析，找出代码错误，比如类型检查，对象是否实现某个方法。
5、类型检查分为动态和静态，静态在编译时做检查，动态检查在运行时做检查。
6、代码生成LLVM，然后进行优化。
7、最后AST生成IR，是一种接近机器码的语言，和平台无关。通过IR可以生成多份适合不同平台的机器码。

+ 预处理
 + 符号化 (Tokenization)
 + 宏定义的展开
 + include 的展开
+ 语法和语义分析
    + 将符号化后的内容转化为一棵解析树 (parse tree)
    + 解析树做语义分析
    + 输出一棵抽象语法树（Abstract Syntax Tree* (AST)）
+ 生成代码和优化
    + 将 AST 转换为更低级的中间码 (LLVM IR)
    + 对生成的中间码做优化
    + 生成特定目标代码
    + 输出汇编代码
+ 汇编器
    + 将汇编代码转换为目标对象文件。
+ 链接器
    + 将多个目标对象文件合并为一个可执行文件 (或者一个动态库)

#### 静态链接和动态链接的区别

静态链接就是把符号绑定到内存地址上。经过编译之后，每个源文件都会被编译成.o文件，最后通过链接器合成一个Mach-O文件，在链接的过程中会创建一个符号表，把所有定义的和未定义的的所有符号记录在符号表中。

简单的回答就是：扫描所有目标文件，收集所有符号和引用地址存放到一个符号表中，然后计算合并后的长度和位置，将相同段内的符号进行合并，进行绑定。对不同文件内的符号进行地址重定位。

动态链接主要是针对动态库，动态库是共享的。动态库是在运行时由dyld进行动态链接，所以不会参与到Mach-O 文件的编译，目标文件内对动态库的引用的符号是未定义的，他们的名字和对应的库会被记录下来，通过dlopen打开动态库返回的就是引用的指针，dlsysm 会通过返回的函数符号得到对应的地址。

根据Mach-O未定义的符号加载对应的动态库，系统会提供一个共享链接库来提升连接速度，将符号绑定到动态库里对应的地址上。

#### 静态链接了解么？静态库和动态库的区别?

链接器最主要的作用，将符号绑定到地址上。LLVM对每个文件进行编译生成Mach-O，Mach-O里面主要是代码和数据。代码是函数的定义，数据是全局变量的定义，包括全部变量的初始化。

链接器的作用，就是完成变量、函数符号和其他地址绑定的任务。链接器在链接多个目标文件的过程中，会创建一个符号表，用于记录所有已定义的和所有未定义的符号。

链接器做的事情：

+ 去项目文件里查找目标代码文件中没有定义的变量。
+ 扫描项目的不同文件，将所有符号定义和引用地址收集寄来，并放到全局符号表中。
+ 计算合并后长度和位置，生成同类型段的进行合并，建立绑定。
+ 对项目中不同文件里的变量进行地址重定位。

+ 静态库 .a 和 .framework
+ 动态库 .dylib 和 .framework
+ 在链接阶段，静态库会被完整的复制到可执行文件中，被多次使用就会有多份冗余拷贝。动态库在链接时不会复制，由系统加载到内存中，供程序使用，系统只加载一次，多个程序共用，节约内存。

#### 内存的几大区域，各自的职能分别是什么？

+ 栈区stack。由编译器自动分配内存，程序结束时自动释放。存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。先进后出，程序员无法控制。
+ 堆区heap。在内存上开辟另外一块存储区域，程序员主动申请和释放内存，如果程序员不主动释放，程序结束由系统释放。
+ 全局存储区，也叫静态存储区。分为DATA段和BSS段。DATA段是全局初始化区，存放初始化的全局变量和静态变量。BSS段是全局未初始化区，存放未初始化的全局变量和静态变量。程序运行结束后自动释放，BSS段在程序执行之前会被系统自动清0.
+ 文字常量区。存放常量字符串，只读状态，不可修改，程序结束后由系统释放。
+ 程序代码区。存放程序的二进制代码。

#### static和const有什么区别？

static 修饰的变量和函数会被延长生命周期，被修饰的类型会保存在bss端，内存由编译器分配，一般程序结束后清除释放。限制其作用域，只在其声明的源文件中有效。

const 修饰的数据是常量，不可被修改。位于常量区，可以修饰全局变量和局部变量，修饰全局变量时，外部不可访问并且进行修改，局部常量也不可修改。

extern 声明外部全局变量，只能用于声明，不能用于实现。用其声明外部全局变量或常量。

#### 了解内联函数么？

内联函数和的效率和宏变量差不多，但是可靠性比宏定义好很多。可以设置断点、类型检查和避免异常行为。

+ 内联函数也叫编译器扩展函数，就是在编译器的时候将函数体插入并取代每一处调用该函数的上下文。从而节省每次调用函数的额外开支。
+ 类型检查，宏不进行类型检查。内联函数可以进行类型检查和避免异常行为。
+ 宏只是文本替换。
+ 内联函数可以设置断点，进行调试。